import asyncpg
import builtins
import db.model
import typing

class AsyncQuerier:

    def __init__(self, pool: asyncpg.Pool) -> None:
        self.__pool = pool

    async def create_users_table(self) -> None:
        async with self.__pool.acquire() as conn:
            await conn.execute('CREATE TABLE IF NOT EXISTS "users" ("id" INT GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY, "name" VARCHAR(256) NOT NULL, "created_at" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP, "account_id" INT)')

    async def create_user(self, *, user_id: builtins.int, user_name: builtins.str) -> typing.Optional[db.model.UsersRow]:
        async with self.__pool.acquire() as conn:
            row = await conn.fetchrow('INSERT INTO "users" ("id", "name") VALUES ($1, $2) RETURNING "id", "name", "created_at"', user_id, user_name)
        return db.model.UsersRow(id=row[0], name=row[1], created_at=row[2]) if row is not None else None

    async def get_user_by_id(self, *, user_id: builtins.int) -> typing.Optional[db.model.UsersRow]:
        async with self.__pool.acquire() as conn:
            row = await conn.fetchrow('SELECT "users"."id" AS "id", "users"."name" AS "name", "users"."created_at" AS "created_at" FROM "users" AS "users" WHERE "users"."id" = $1 LIMIT 1', user_id)
        return db.model.UsersRow(id=row[0], name=row[1], created_at=row[2]) if row is not None else None

    async def search_users_by_name_ilike(self, *, limit: builtins.int, user_name_pattern: builtins.str) -> typing.Sequence[db.model.UsersRow]:
        async with self.__pool.acquire() as conn:
            rows = await conn.fetch('SELECT "users"."id" AS "id", "users"."name" AS "name", "users"."created_at" AS "created_at" FROM "users" AS "users" WHERE "users"."name" ILIKE $1 LIMIT $2', user_name_pattern, limit)
        return [db.model.UsersRow(id=row[0], name=row[1], created_at=row[2]) for row in rows]